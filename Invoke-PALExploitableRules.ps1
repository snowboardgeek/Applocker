function Invoke-PALExploitableRules
{
<#
.SYNOPSIS

Gets AppLocker rules that potentially can be exploited.

Author: @oddvarmoe
License: BSD 3-Clause
Required Dependencies: Get-PALRules, Get-PALRulesStatus, Get-PALWriteableAllowedPaths
Optional Dependencies: None

.DESCRIPTION

Checking AppLocker rules and looks for known weaknesses in configuration that can be exploited.

.EXAMPLE

PS C:\> Get-PALExploitableRules

Get-PALExploitableRules

[*] Checking for Exploitable AppLocker rules

[*] Checking Publisher rules
[+] Trust all signed rule found in Appx
[+] Get yourself a code signing cert and start a party!


Ruletype      : FilePublisherRule
Action        : Allow
SID           : S-1-1-0
Description   : Allows members of the Everyone group to run packaged apps that are signed.
Name          : (Default Rule) All signed packaged apps
Id            : a9e18c21-ff8f-43cf-b9fc-db40eed693ba
PublisherName : *
Productname   : *
BinaryName    : *
LowSection    : 0.0.0.0
HighSection   : *

[+] Trust all signed rule found in Msi
[+] Get yourself a code signing cert and start a party!
Ruletype      : FilePublisherRule
Action        : Allow
SID           : S-1-1-0
Description   : Allows members of the Everyone group to run digitally signed Windows Installer files.
Name          : (Default Rule) All digitally signed Windows Installer files
Id            : b7af7102-efde-4369-8a89-7a6a392d1473
PublisherName : *
Productname   : *
BinaryName    : *
LowSection    : 0.0.0.0
HighSection   : *


[*] Checking for missing or incorrect path rules
[+] Did not find any deny rules
[+] Did not find any rules blocking executing from Alternate Data Streams
[+] Exploit by adding a binary to a stream of a folder inside an allowed path. EX: type file.exe > c:\windows\tasks:file.exe

[*] Checking for denied AppLocker hash rules
[+] Did not find any hash deny rules
#>
# Function Version: 0.80    
    [CmdletBinding()] Param (
        [String]$OfflineXML
    )
    Process
    {
        Try
        {
            If($OfflineXML)
            {
                "`n[*] Checking for Exploitable AppLocker rules from Offline XML"
                $PublisherRules = Get-PALRulesNative -OutputRules Publisher -RuleActions Allow -OfflineXML $OfflineXML
                $DenyPathRules = Get-PALRulesNative -OutputRules Path -RuleActions Deny -OfflineXML $OfflineXML
                $DenyHashRules = Get-PALRulesNative -OutputRules Hash -RuleActions Deny -OfflineXML $OfflineXML
            }
            else
            {
                "`n[*] Checking for Exploitable AppLocker rules"
                $PublisherRules = Get-PALRules -OutputRules Publisher -RuleActions Allow
                $DenyPathRules = Get-PALRules -OutputRules Path -RuleActions Deny
                $DenyHashRules = Get-PALRules -OutputRules Hash -RuleActions Deny
            }
            
            #Check if there exists a trust all signed binaries rule
            "`n[*] Checking Publisher rules"
            if($PublisherRules)
            {
                ForEach($Pubr in $PublisherRules)
                {
                    if($pubr.RulesList.Publishername -eq "*")
                    {
                        "[+] Trust all signed rule found in $($pubr.name)"
                        "[+] Get yourself a code signing cert and start a party!"
                        $pubr.RulesList
                    }
                }
            }

            ##### #### ##### 
            ###
            # NEED A FUNCTION THAT FIGURES OUT WRITABLE LOCATIONS THAT DOES NOT HAVE A DENY RULE APPLIED IN TERMS OF ADS#
            ###
            ##### #### #####
            #Check if there is an incorrect path rule
            "`n[*] Checking for missing or incorrect path rules"
            if($DenyPathRules)
            {
                if(!($DenyPathRules.RulesList.RulePath -match "\:\*$"))
                    {
                       "[+] Did not find any rules blocking execution from Alternate Data Streams"
                    }

                ForEach($DPR in $DenyPathRules.RulesList)
                {
                    if(!($($DPR.RulePath) -match "\\\*$" -or $($DPR.RulePath) -match "\.\w{2,4}$" -or $($DPR.RulePath) -match ":\*"))
                    {
                        "[+] Found misconfigured deny path rule - Missing asterix (*) - Rule has no effect"
                        $DPR    
                    }

                    #if(!($DPR -match "\:\*$"))
                    #{
                    #   "[+] Did not find any rules blocking execution from Alternate Data Streams"
                    #}
                }
            }
            else{
                "[+] Did not find any deny rules"
                "[+] Did not find any rules blocking execution from Alternate Data Streams"
                "[+] Exploit by adding a binary to a stream of a folder inside an allowed path. EX: type file.exe > c:\windows\tasks:file.exe"
            }

            #Check if there are rules that denies a file hash
            "`n[*] Checking for denied AppLocker hash rules"
            if($DenyHashRules)
            {
                ForEach($HR in $DenyHashRules)
                {
                    "[+] Found hash deny rule" 
                    "[+] - Add content to file and execute: copy /b blockedfile.exe+txtfile.txt newfile.txt"
                    $HR.RulesList | fl *
                }
            }
            else
            {
                "[-] Did not find any hash deny rules"
            }

            #Check if some of the rule collections is not configured
            "`n[*] Checking rule collection status to see if one collection is not enabled"
            $RulesStatus = Get-PALRuleSectionStatus
            foreach($Ruless in $RulesStatus)
            {
                if($Ruless.status -ne "Enforced")
                {
                    "[+] $($Ruless.Name) is not enforced. Have fun!"
                }
            }

             #Check for allow rules on root folder

            #Check if Powershell v2 is allowed or not!
            "`n[*] Checking if PowerShell version 2 is enabled"
            $Posh2Enabled = Get-PALPoshV2Installed
            if($Posh2Enabled -eq "True")
            {
                "[+] Found that Powershell version 2 is enabled"
                "[+] Start Powershell with command: powershell -version 2"
            }
            else
            {
                "[-] Found that Powershell version 2 is disabled"
            }


            #Check for potential CLM bypass
            "`n[*] Checking for potential CLM bypass"
            #A bug... Needs to run it once before I can use rulesection and get the correct count
            #must be something related to global variables
            Get-PALWriteableAllowedPaths | Out-Null
            $CLMInjectiblePaths = Get-PALWriteableAllowedPaths -RuleSection Script
            If($($CLMInjectiblePaths.count) -eq "0")
            {
                
                "[-] No user writeable allowed paths found for CLM bypass"
            }
            else
            {
                "[+] Found $($CLMInjectiblePaths.count) potential paths that can be used for CLM bypass"
                "[+] Use Invoke-PALCLMTempBypass to attempt to launch a full language mode PowerShell session"
            }


           
        }
        Catch
        {
            write-error $_
        }
        Finally{}
    }
}
